"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _driver = require("./driver");

var _error = require("./error");

var _connectionProviderRouting = _interopRequireDefault(require("./internal/connection-provider-routing"));

var _leastConnectedLoadBalancingStrategy = _interopRequireDefault(require("./internal/least-connected-load-balancing-strategy"));

var _connectionErrorHandler = _interopRequireDefault(require("./internal/connection-error-handler"));

var _configuredCustomResolver = _interopRequireDefault(require("./internal/resolver/configured-custom-resolver"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/**
 * A driver that supports routing in a causal cluster.
 * @private
 */
var RoutingDriver = /*#__PURE__*/function (_Driver) {
  (0, _inherits2["default"])(RoutingDriver, _Driver);

  var _super = _createSuper(RoutingDriver);

  function RoutingDriver(address, routingContext, userAgent) {
    var _this;

    var token = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var config = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    (0, _classCallCheck2["default"])(this, RoutingDriver);
    _this = _super.call(this, address, userAgent, token, validateConfig(config));
    _this._routingContext = routingContext;
    return _this;
  }

  (0, _createClass2["default"])(RoutingDriver, [{
    key: "_afterConstruction",
    value: function _afterConstruction() {
      this._log.info("Routing driver ".concat(this._id, " created for server address ").concat(this._address));
    }
  }, {
    key: "_createConnectionProvider",
    value: function _createConnectionProvider(address, userAgent, authToken) {
      return new _connectionProviderRouting["default"]({
        id: this._id,
        address: address,
        routingContext: this._routingContext,
        hostNameResolver: createHostNameResolver(this._config),
        config: this._config,
        log: this._log,
        userAgent: userAgent,
        authToken: authToken
      });
    }
  }, {
    key: "_supportsRouting",
    value: function _supportsRouting() {
      return true;
    }
  }]);
  return RoutingDriver;
}(_driver.Driver);
/**
 * @private
 * @returns {ConfiguredCustomResolver} new custom resolver that wraps the passed-in resolver function.
 *              If resolved function is not specified, it defaults to an identity resolver.
 */


function createHostNameResolver(config) {
  return new _configuredCustomResolver["default"](config.resolver);
}
/**
 * @private
 * @returns {Object} the given config.
 */


function validateConfig(config) {
  var resolver = config.resolver;

  if (resolver && typeof resolver !== 'function') {
    throw new TypeError("Configured resolver should be a function. Got: ".concat(resolver));
  }

  return config;
}

var _default = RoutingDriver;
exports["default"] = _default;